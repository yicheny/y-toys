
# 基础知识
由几个重要概念需要了解下：
- 数据库
- 对象存储区【数据仓库】
- 事务
- 游标

## 一个找人的案例
举一个例子说明下：

衡水中学有6000多名学生【含初中】，每个班级约有70人。

假设现在在衡水中学，
- 校长有权限拿到全校学生的信息，
- 年级主任有权限拿到所负责年级的学生信息，
- 班主任可以拿到所在班级的学生信息。

现在我想在某个班级里找一个叫做“章方昕”的人，如果一个个去找效率会很低，幸运的是我知道他是高一学生。

我找到高一年级主任郭春雨，希望可以得到章方昕的信息。

郭春雨愿意提供帮助，不过可惜的是他们现在没有使用电子系统管理信息，只有纸质表格，高一年级约1000名学生，而且很坑的是，他们的表格并没有通过名称顺序排列，只有两份列表：
1. 以班级排序，班级内部以入学为顺序的表格
2. 经过处理的，全年级以身高为顺序的表格，

现在我要怎么快速找到章方昕呢？我还有一个很重要的信息，章方昕的身高是185

通过这个信息，我快速定位到相关身高区间，身高185的学生有47人，我进行排查，很快找到了章方昕，他在高一（7）班。

## 模型分析
刚刚故事的内容是表象，它的抽象内质和数据库是相似的，看完刚刚的故事，有益于理解数据库相关概念。

我描述下数据库的做法：

我有一个数据库，数据库名称是“衡水中学”，数据库里有很多对象存储区，每个对象存储区存储约70名学生的信息。

我现在想要查找一个叫做“章方昕”的学生信息，可惜我不知道他被存储到哪个区了，如果我直接以`{name:'章方昕'}`这个条件进行查询，现在有6000多条数据，数据库会这么找：

![遍历顺序查询](https://pic.imgdb.cn/item/61a06a022ab3f51d9182dfad.jpg)

假设章方昕出现在任意位置的机会是均等的，那么可以计算得到复杂度是：

```
//出现在第n个位置需要遍历n次，出现位置是相等的，所以需要除以n
(1+2+3+……+(n-2)+(n-1)+n) / n  
= ((n+1) + (n-1+2) + (n-2+3) + ...) / n
= (n+1 * (n/2)) / n
= (1/2 * (n^2+n)) / n
= 1/2 * (n+1)
=> O(n) 
```
这里稍微说一下，使用大`O`表示法会省略常数，比如无论是`n`、`2n`、`2.5n`，用大`O`表示法都是`O(n)`

如果上述说明不太理解，问题也不大，我们可以认为章方昕的信息会出现在中间位置，在第`3001`遍历时可以得到章方昕的信息。

这种遍历方式是很低效的，如果只有几百条、几千条可能感受不到，如果是上千万、上亿级别的大数据量，这种查询方式会非常慢。

下面我会介绍一些关于“索引”的基础知识，索引是优化查询时最常用的一种手段。

以前我写爬虫时就用过索引，当时我将一个影视网站的数据整个爬了下来，存储到`moogoseDB`数据库中，数据包括数十万部电影信息，每部电影信息都较为详尽，包括参与演员、发行年份、评分、标签等等。

在没有建立索引的情况下查询指定信息，比如说某个演员相关的所有电影，速度是很慢的，大概需要几十秒左右，之后我将演员作为键建立索引，查询速度是`0.0006`秒，速度提升可见一斑。

我们创建对象存储区【表】时，必须指定主键，在有些关系型数据库中，如果建表时没有指定主键，则不允许创建。有些数据库允许创建没有主键的表，此时数据是无序存放的。

主键是最通用的索引，非常重要。因为索引不是无序放置数据的，它会以特定的数据结构进行存储，查询速度会得到极大提升。

不过索引并不一定是主键，主键只有一个，索引可以有很多个。

索引有`uniq`属性，以控制键是否唯一，比如姓名啊、身高这种就并不唯一，可以重复；而身份证号、`id`这种需要保证唯一。

索引的数据结构实现，根据不同数据库会有不同实现，常见的有3种：
1. 桶结构
2. 哈希表【散列表】
3. `B-tree`【平衡树——这个用的最多】

我们看一下使用这三种结构查询效率会有什么不同，

## 桶结构
首先是桶结构，假设我用身高做索引。
1. 准备100个桶【内存地址】，分别用于标识`101`-`200`的身高 
> 最大最小值很容易拿到，而且也很容易修改

![](https://pic.imgdb.cn/item/61a0848c2ab3f51d918e3037.jpg)

2. 存储数据时，将数据放到对应的桶里，类似这样：

![](https://pic.imgdb.cn/item/61a085272ab3f51d918e760a.jpg)

3. 查询数据时，比如查`185`，请问查询速度是多少？

答案是`O(1)`

桶结构在排序时有奇效，比如我们如果想要为学校的学生以身高排序，我们以桶结构存储，查询时依次从桶中取出数据，得到的就是排序后的结果了

![](https://pic.imgdb.cn/item/61a09db82ab3f51d9199c2b1.jpg)


> 这里特别说明下，正常初始和结束的桶都不会是空的，空的只会是中间桶，原因各位可以想一想

可以发现，如果以桶结构存储，排序超级快速，即便是百万级别，千万级别的数据，桶排序速度始终稳定是`O(1)`。

不过如此强大的桶排序，并不适用于所有场景，它的缺陷在于：
1. 内存空间的浪费

假设现在我们要对`(1,100000000)`这两个数字进行排序，那么桶排序会占据`100000000`（1亿）个内存地址，这很显然比较浪费。

2. 对于非整数类的数据难于放置

比如现在有一个属性是价格，它的区间不大，只是`0-1000`，但是它的精细度是`0.00000001`，这种时候用桶结构就不太合理。

## 哈希表
...待补充

## `B-tree`
...待补充

# 接口设计
- `constructor({dbName:string,version:number})` 连接指定数据库
- `querySync(key:TKey):any` 查询并返回第一条符合条件的项
- `queryAllSync(key:TKey):any` 查询并返回所有符合条件的项
- `addOne(data:TData):void` 在当前仓库添加一条数据项
- `addMany(datas:TData[]):void` 在当前仓库添加多条数据项
- `deleteOne():void` 在当前仓库删除一条数据项
- `deleteMany(keys:Tkey[]):void` 在当前仓库删除多条数据项
- `clear():void` 清空指定仓库
- `updateOne(data:TData):void` 更新指定数据项
- `updateMany(datas:TData[]):void` 更新多条数据项
